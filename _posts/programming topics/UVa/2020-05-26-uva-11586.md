---
layout: post
title: UVa 11586 - Train Tracks
tags: [UVa]
---

An important observation is that if you have two pieces as $MF$ and $FM$, then you could piece them together to form a loop. See the picture below for clarification:

<figure>
<img src="/assets/img/programming_topics/uva-11586.jpeg" width="700" height="500" class="center">
<figcaption> MF and FM combination </figcaption>  
</figure>

But if we had only one $MF$ or only one $FM$, then a loop couldn't be formed because the problem states that: "You may not connect the two ends of the same piece together."

Now, here comes another interesting observation. We've just seen from the above example that $MF$ and $FM$ pieces are basically the same. So, if we have more than one $MF$ or $FM$, then a loop can always be formed with them!


<figure>
<img src="/assets/img/programming_topics/uva-11586-2.jpeg" width="700" height="500" class="center">
<figcaption> MF and FM combination </figcaption>  
</figure>

Now comes the $MM$ or $F$ pieces. Observe that, to form a loop, a $MM$ piece must always be accompanied by a $FF$ piece. No matter how many $MF$ or $FM$ pieces there are, if there aren't equal number of $MM$ and $FF$ piecies (same parity), a loop can't be formed. 

With all that in mind, here's my implementation in ``C++``:

{% highlight C++ linenos %}
#include <iostream>
#include <unordered_map>
#include <sstream>
#include <limits>

int main(int argc, char const *argv[])
{
    int T;
    std::cin >> T;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    while(T--){
        std::string pieces;
        std::getline(std::cin, pieces);
        std::unordered_map<std::string,int> counter;
        {
            std::string piece;
            std::istringstream iss(pieces);
            while(iss >> piece){
                if(piece == "FM") piece = "MF";
                ++counter[piece];
            }
        }

        bool loop = false;
        if(counter["MF"]){
            if(!counter["MM"] && !counter["FF"]){
                if(counter["MF"] > 1) {
                    loop = true;
                }
            } else if(counter["MM"] == counter["FF"]){
                loop = true;
            }
        } else if(counter["MM"] > 0 && counter["FF"] > 0 && counter["MM"] == counter["FF"]) {
            loop = true;
        }

        if(loop){
            std::cout << "LOOP\n";
        } else{
            std::cout << "NO LOOP\n";
        }
    }
    return 0;
}
{% endhighlight %}