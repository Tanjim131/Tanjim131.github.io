---
layout: post
title: UVa 455 - Periodic Strings
tags: [UVa]
---

An easy problem. We just need to take each substring $s_{sub}$ of the given string $s$ in increasing length order and check if it matches the constraints. What are the constraints? 

 - Length of $s_{sub}$ divides evenly into length of $s$. Let, $\ddfrac{s.\textrm{length}}{s_{sub}.length} = q$.
 - When $s_{sub}$ is concatenated $q$ times, it matches with $s$. 

 Given the above two constraints, here's the implementation in ``C++``:

{% highlight C++ linenos %}
#include <iostream>

int main(int argc, char const *argv[])
{
    int T, k = 0;
    std::cin >> T;
    while(T--){
        std::string input;
        std::cin >> input;
        if(k > 0) std::cout << '\n';
        for(int i = 0 ; i < input.length() ; ++i){
            int substring_length = i + 1;
            if(input.length() % substring_length) continue;
            // check if this substring is the one with the smallest period
            std::string substring(input.substr(0, substring_length));
            int times = input.length() / substring.length();
            std::string concat;
            for(int i = 0 ; i < times ; ++i){
                concat += substring;
            }
            if(concat == input){
                std::cout << substring.length() << '\n';
                break;
            }
        }
        ++k;
    }
    return 0;
}
{% endhighlight %}

Worst case time complexity is $\mathcal{O}(n^2)$, where $n$ is the input size. This happens when the smallest period is the input string length. 