---
layout: post
title: UVa 927 - Integer Sequences from Addition of Terms
tags: [UVa]
---

***Problem Statement***: We're given a polynomial $a_n$ of degree $i$ with non-negative integer coefficients. $a_n$ can be expressed as followed: 

\\[ a_n = c_0 + c_1n + c_2n^2 + c_3n^3 + \cdots + c_in^i\\]

We can construct a sequence from the given polynomial $a_n$ for different values of $n$. We denote this sequence as $ \\{ a_n \\} $. So it can be $\\{a_1, a_2, a_3,\ldots\\}$ for $ n = 1, 2, 3, \ldots$. 

We're also given two positive integers $d$ and $k$. Another sequence $\\{b_m\\}$ is constructed for $m = 1,2,3,\ldots$ where $b_m$ is the term $a_n$ repeated $n \times d$ times. So for example, when $d = 2$, $b_1$ will be two occurrences of $a_1$. $b_2$ will be four occurrences of $a_2$ and so on. 

Given all this, we're told to find the $k$-th integer in the sequence $\\{b_m\\}$.

***Solution***: We compute $a_n$ for increasing value of $n$. For each value of $n$, we know that $a_n$ will repeated $n \times d$ times. We add the number of occurrences to a variable called $\textrm{counter}$. When $\textrm{counter} \geq k$, we stop and print $a_n$ for that particular value of $n$. 

Here's the implementation in ``C++``:

{% highlight C++ linenos %}
#include <iostream>                                                             
#include <vector>

inline long long power(long long base, long long exponent){
    long long ans = 1;
    while(exponent--){
        ans *= base;
    }
    return ans;
}

int main(int argc, char const *argv[])
{
    int C; 
    std::cin >> C;
    while(C--){
        int degree;
        std::cin >> degree;
        std::vector <int> coefficients(degree + 1);
        for(int i = 0 ; i < coefficients.size() ; ++i){
            std::cin >> coefficients[i];
        }
        int d,k;
        std::cin >> d >> k;
        int counter = 0;
        int n = 1;
        while(true){
            long long a_n = 0;
            for(int i = 0 ; i < coefficients.size() ; ++i){
                a_n += coefficients[i] * power(n, i);
            }
            counter += n * d;
            if(counter >= k){
                std::cout << a_n << '\n';
                break;
            } 
            ++n;
        }
    }
    return 0;
}
{% endhighlight %}

What is the worst case time complexity of the above program? To find that out, we only need to figure out the time complexity of the ``while`` loop block between line $27-38$. 

In the worst case, the $\textrm{counter}$ variable increases as slowly as possible to catch up to $k$. So, we need to make $d$ as low as possible and $k$ as high as possible. 

We have $d_{min} = 1$ and $k_{max} = 10^6$. How many times the ``while`` loop will iterate? $\textrm{counter}$ becomes $1$, $2$, $3$, and so on. Also, this sequence can't go on forever otherwise the ``while`` loop won't terminate. Let $p$ be the last term of this sequence. So we have,

\\[ 1 + 2 + 3 + \ldots + p = k_{max} = 10^6\\]
\\[ \implies \ddfrac{p(p + 1)}{2} = 10^6\\]
\\[ \implies p \approx 1414 \\]

So, the inner ``while`` loop will iterate at most $1414$ times. For highest degree, $i_{max} = 20$, the total iteration becomes $1414 \times 20 \approx 30000$. 
