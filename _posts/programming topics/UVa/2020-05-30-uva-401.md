---
layout: post
title: UVa 401 - Palindromes
tags: [UVa]
---

Pretty straightforward problem. But I made one small mistake when checking for ``mirrored strings``.

Let's say you have a string $s$. When you check for $s$ to be a palindrome, you start iterating from index $0$ and iterate just before index $\floor{\ddfrac{s.length}{2}}$. We can express it in terms of range as $\bigg[0,\floor{\ddfrac{s.length}{2}}\bigg)$. 

If length of $s$ is even, all the characters are compared. For example, if $s = \textrm{ABBA}$, then $(A,A)$ and $(B,B)$ pairs are checked. But if the length is odd, then the middle character, namely the character at index $\ddfrac{s.length + 1}{2}$ is left alone, otherwise we would be checking it with itself which would obviously return true. For example, if $s = \textrm{ABA}$, then only $(A,A)$ pair is checked. $B$ is not compared with itself. 

But that's not the case when you're dealing with mirrored palindromes. In case the length is even, it's business as usual. But if the length is odd, then you would also have to check if the middle character is reverse of itself or not. I forgot to check it!

Let's see the difference in code. 

Here's the ``isRegularPalindrome`` function:

{% highlight C++ linenos %}
bool isRegularPalindrome(const std::string &str){                         
    for(int i = 0 ; i < str.length() / 2 ; ++i){
        if(str[i] != str[str.length() - 1 - i]) return false;
    }
    return true;
}
{% endhighlight %}

and here's the ``isMirroredString`` function:

{% highlight C++ linenos %}
bool isMirroredString(const std::string &str, 
                        const std::unordered_map<char,char> &reverseList)
{
    for(int i = 0 ; i <= str.length() / 2 ; ++i){
        char first = str[i];
        char last = str[str.length() - 1 - i];
        if(reverseList.find(first) == reverseList.end()) return false;
        char mirrored = reverseList.at(first);
        if(mirrored != last) return false;
    }
    return true;
}
{% endhighlight %}

See the difference in the ``for`` loop termination? Essentially in case of mirrored strings, we're checking up to $\floor{\ddfrac{s.length}{2}}$, namely the middle character is also checked for reverse. 

We can also express it in terms of range,

\\[ \bigg[0,\floor{\ddfrac{s.length}{2}}\bigg) \longleftarrow \textrm{Regular Palindrome} \\]
\\[ \bigg[0,\floor{\ddfrac{s.length}{2}}\bigg ] \longleftarrow \textrm{Mirrored String} \\]

Here's the final implementation in ``C++``:

{% highlight C++ linenos %}
#include <iostream>
#include <unordered_map>

std::unordered_map<char,char> generateReverse(){
     std::unordered_map<char,char> reverseList = {
        {'A', 'A'},
        {'E', '3'},
        {'H', 'H'},
        {'I', 'I'},
        {'J', 'L'},
        {'L', 'J'},
        {'M', 'M'},
        {'O', 'O'},
        {'S', '2'},
        {'T', 'T'},
        {'U', 'U'},
        {'V', 'V'},
        {'W', 'W'},
        {'X', 'X'},
        {'Y', 'Y'},
        {'Z', '5'},
        {'1', '1'},
        {'2', 'S'},
        {'3', 'E'},
        {'5', 'Z'},
        {'8', '8'}
    };
    return reverseList;
}

bool isRegularPalindrome(const std::string &str){
    for(int i = 0 ; i < str.length() / 2 ; ++i){
        if(str[i] != str[str.length() - 1 - i]) return false;
    }
    return true;
}

bool isMirroredString(const std::string &str, 
                        const std::unordered_map<char,char> &reverseList)
{
    for(int i = 0 ; i <= str.length() / 2 ; ++i){
        char first = str[i];
        char last = str[str.length() - 1 - i];
        if(reverseList.find(first) == reverseList.end()) return false;
        char mirrored = reverseList.at(first);
        if(mirrored != last) return false;
    }
    return true;
}

int main(int argc, char const *argv[])
{
    std::unordered_map <char,char> reverseList = generateReverse();
    std::string input;
    while(std::getline(std::cin, input)){
        bool retPalindrome = isRegularPalindrome(input);
        bool retMirrored = isMirroredString(input, reverseList);
        if(!retPalindrome && !retMirrored){
            std::cout << input << " -- is not a palindrome.\n";
        } else if(retPalindrome && !retMirrored){
            std::cout << input << " -- is a regular palindrome.\n";
        } else if(retMirrored && !retPalindrome){
            std::cout << input << " -- is a mirrored string.\n";
        } else{
            std::cout << input << " -- is a mirrored palindrome.\n";
        }
        std::cout << '\n';
    }
    return 0;
}
{% endhighlight %}